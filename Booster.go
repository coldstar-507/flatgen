// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package flatgen

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

type BoosterT struct {
	BoostId string `json:"boost_id"`
	Token string `json:"token"`
	DeviceId string `json:"device_id"`
	SenderId string `json:"sender_id"`
	ChangeAddress []byte `json:"change_address"`
	S1 []byte `json:"s1"`
	PricePerHead int64 `json:"price_per_head"`
	InputSats int64 `json:"input_sats"`
	PartialTx []byte `json:"partial_tx"`
	Limit int64 `json:"limit"`
	MaxAge int64 `json:"max_age"`
	MinAge int64 `json:"min_age"`
	Genders []string `json:"genders"`
	Interests []string `json:"interests"`
	Areas []*AreaT `json:"areas"`
	BoostMessage []byte `json:"boost_message"`
	FullMedia []byte `json:"full_media"`
}

func (t *BoosterT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil { return 0 }
	boostIdOffset := builder.CreateString(t.BoostId)
	tokenOffset := builder.CreateString(t.Token)
	deviceIdOffset := builder.CreateString(t.DeviceId)
	senderIdOffset := builder.CreateString(t.SenderId)
	changeAddressOffset := flatbuffers.UOffsetT(0)
	if t.ChangeAddress != nil {
		changeAddressOffset = builder.CreateByteString(t.ChangeAddress)
	}
	s1Offset := flatbuffers.UOffsetT(0)
	if t.S1 != nil {
		s1Offset = builder.CreateByteString(t.S1)
	}
	partialTxOffset := flatbuffers.UOffsetT(0)
	if t.PartialTx != nil {
		partialTxOffset = builder.CreateByteString(t.PartialTx)
	}
	gendersOffset := flatbuffers.UOffsetT(0)
	if t.Genders != nil {
		gendersLength := len(t.Genders)
		gendersOffsets := make([]flatbuffers.UOffsetT, gendersLength)
		for j := 0; j < gendersLength; j++ {
			gendersOffsets[j] = builder.CreateString(t.Genders[j])
		}
		BoosterStartGendersVector(builder, gendersLength)
		for j := gendersLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(gendersOffsets[j])
		}
		gendersOffset = builder.EndVector(gendersLength)
	}
	interestsOffset := flatbuffers.UOffsetT(0)
	if t.Interests != nil {
		interestsLength := len(t.Interests)
		interestsOffsets := make([]flatbuffers.UOffsetT, interestsLength)
		for j := 0; j < interestsLength; j++ {
			interestsOffsets[j] = builder.CreateString(t.Interests[j])
		}
		BoosterStartInterestsVector(builder, interestsLength)
		for j := interestsLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(interestsOffsets[j])
		}
		interestsOffset = builder.EndVector(interestsLength)
	}
	areasOffset := flatbuffers.UOffsetT(0)
	if t.Areas != nil {
		areasLength := len(t.Areas)
		areasOffsets := make([]flatbuffers.UOffsetT, areasLength)
		for j := 0; j < areasLength; j++ {
			areasOffsets[j] = t.Areas[j].Pack(builder)
		}
		BoosterStartAreasVector(builder, areasLength)
		for j := areasLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(areasOffsets[j])
		}
		areasOffset = builder.EndVector(areasLength)
	}
	boostMessageOffset := flatbuffers.UOffsetT(0)
	if t.BoostMessage != nil {
		boostMessageOffset = builder.CreateByteString(t.BoostMessage)
	}
	fullMediaOffset := flatbuffers.UOffsetT(0)
	if t.FullMedia != nil {
		fullMediaOffset = builder.CreateByteString(t.FullMedia)
	}
	BoosterStart(builder)
	BoosterAddBoostId(builder, boostIdOffset)
	BoosterAddToken(builder, tokenOffset)
	BoosterAddDeviceId(builder, deviceIdOffset)
	BoosterAddSenderId(builder, senderIdOffset)
	BoosterAddChangeAddress(builder, changeAddressOffset)
	BoosterAddS1(builder, s1Offset)
	BoosterAddPricePerHead(builder, t.PricePerHead)
	BoosterAddInputSats(builder, t.InputSats)
	BoosterAddPartialTx(builder, partialTxOffset)
	BoosterAddLimit(builder, t.Limit)
	BoosterAddMaxAge(builder, t.MaxAge)
	BoosterAddMinAge(builder, t.MinAge)
	BoosterAddGenders(builder, gendersOffset)
	BoosterAddInterests(builder, interestsOffset)
	BoosterAddAreas(builder, areasOffset)
	BoosterAddBoostMessage(builder, boostMessageOffset)
	BoosterAddFullMedia(builder, fullMediaOffset)
	return BoosterEnd(builder)
}

func (rcv *Booster) UnPackTo(t *BoosterT) {
	t.BoostId = string(rcv.BoostId())
	t.Token = string(rcv.Token())
	t.DeviceId = string(rcv.DeviceId())
	t.SenderId = string(rcv.SenderId())
	t.ChangeAddress = rcv.ChangeAddressBytes()
	t.S1 = rcv.S1Bytes()
	t.PricePerHead = rcv.PricePerHead()
	t.InputSats = rcv.InputSats()
	t.PartialTx = rcv.PartialTxBytes()
	t.Limit = rcv.Limit()
	t.MaxAge = rcv.MaxAge()
	t.MinAge = rcv.MinAge()
	gendersLength := rcv.GendersLength()
	t.Genders = make([]string, gendersLength)
	for j := 0; j < gendersLength; j++ {
		t.Genders[j] = string(rcv.Genders(j))
	}
	interestsLength := rcv.InterestsLength()
	t.Interests = make([]string, interestsLength)
	for j := 0; j < interestsLength; j++ {
		t.Interests[j] = string(rcv.Interests(j))
	}
	areasLength := rcv.AreasLength()
	t.Areas = make([]*AreaT, areasLength)
	for j := 0; j < areasLength; j++ {
		x := Area{}
		rcv.Areas(&x, j)
		t.Areas[j] = x.UnPack()
	}
	t.BoostMessage = rcv.BoostMessageBytes()
	t.FullMedia = rcv.FullMediaBytes()
}

func (rcv *Booster) UnPack() *BoosterT {
	if rcv == nil { return nil }
	t := &BoosterT{}
	rcv.UnPackTo(t)
	return t
}

type Booster struct {
	_tab flatbuffers.Table
}

func GetRootAsBooster(buf []byte, offset flatbuffers.UOffsetT) *Booster {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Booster{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsBooster(buf []byte, offset flatbuffers.UOffsetT) *Booster {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &Booster{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *Booster) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Booster) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Booster) BoostId() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Booster) Token() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Booster) DeviceId() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Booster) SenderId() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Booster) ChangeAddress(j int) byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetByte(a + flatbuffers.UOffsetT(j*1))
	}
	return 0
}

func (rcv *Booster) ChangeAddressLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Booster) ChangeAddressBytes() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Booster) MutateChangeAddress(j int, n byte) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateByte(a+flatbuffers.UOffsetT(j*1), n)
	}
	return false
}

func (rcv *Booster) S1(j int) byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetByte(a + flatbuffers.UOffsetT(j*1))
	}
	return 0
}

func (rcv *Booster) S1Length() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Booster) S1Bytes() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Booster) MutateS1(j int, n byte) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateByte(a+flatbuffers.UOffsetT(j*1), n)
	}
	return false
}

func (rcv *Booster) PricePerHead() int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.GetInt64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Booster) MutatePricePerHead(n int64) bool {
	return rcv._tab.MutateInt64Slot(16, n)
}

func (rcv *Booster) InputSats() int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.GetInt64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Booster) MutateInputSats(n int64) bool {
	return rcv._tab.MutateInt64Slot(18, n)
}

func (rcv *Booster) PartialTx(j int) byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetByte(a + flatbuffers.UOffsetT(j*1))
	}
	return 0
}

func (rcv *Booster) PartialTxLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Booster) PartialTxBytes() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Booster) MutatePartialTx(j int, n byte) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateByte(a+flatbuffers.UOffsetT(j*1), n)
	}
	return false
}

func (rcv *Booster) Limit() int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		return rcv._tab.GetInt64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Booster) MutateLimit(n int64) bool {
	return rcv._tab.MutateInt64Slot(22, n)
}

func (rcv *Booster) MaxAge() int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		return rcv._tab.GetInt64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Booster) MutateMaxAge(n int64) bool {
	return rcv._tab.MutateInt64Slot(24, n)
}

func (rcv *Booster) MinAge() int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		return rcv._tab.GetInt64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Booster) MutateMinAge(n int64) bool {
	return rcv._tab.MutateInt64Slot(26, n)
}

func (rcv *Booster) Genders(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(28))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *Booster) GendersLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(28))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Booster) Interests(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(30))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *Booster) InterestsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(30))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Booster) Areas(obj *Area, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(32))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Booster) AreasLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(32))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Booster) BoostMessage(j int) byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(34))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetByte(a + flatbuffers.UOffsetT(j*1))
	}
	return 0
}

func (rcv *Booster) BoostMessageLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(34))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Booster) BoostMessageBytes() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(34))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Booster) MutateBoostMessage(j int, n byte) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(34))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateByte(a+flatbuffers.UOffsetT(j*1), n)
	}
	return false
}

func (rcv *Booster) FullMedia(j int) byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(36))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetByte(a + flatbuffers.UOffsetT(j*1))
	}
	return 0
}

func (rcv *Booster) FullMediaLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(36))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Booster) FullMediaBytes() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(36))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Booster) MutateFullMedia(j int, n byte) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(36))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateByte(a+flatbuffers.UOffsetT(j*1), n)
	}
	return false
}

func BoosterStart(builder *flatbuffers.Builder) {
	builder.StartObject(17)
}
func BoosterAddBoostId(builder *flatbuffers.Builder, boostId flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(boostId), 0)
}
func BoosterAddToken(builder *flatbuffers.Builder, token flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(token), 0)
}
func BoosterAddDeviceId(builder *flatbuffers.Builder, deviceId flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(deviceId), 0)
}
func BoosterAddSenderId(builder *flatbuffers.Builder, senderId flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(senderId), 0)
}
func BoosterAddChangeAddress(builder *flatbuffers.Builder, changeAddress flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(changeAddress), 0)
}
func BoosterStartChangeAddressVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(1, numElems, 1)
}
func BoosterAddS1(builder *flatbuffers.Builder, s1 flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(s1), 0)
}
func BoosterStartS1Vector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(1, numElems, 1)
}
func BoosterAddPricePerHead(builder *flatbuffers.Builder, pricePerHead int64) {
	builder.PrependInt64Slot(6, pricePerHead, 0)
}
func BoosterAddInputSats(builder *flatbuffers.Builder, inputSats int64) {
	builder.PrependInt64Slot(7, inputSats, 0)
}
func BoosterAddPartialTx(builder *flatbuffers.Builder, partialTx flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(8, flatbuffers.UOffsetT(partialTx), 0)
}
func BoosterStartPartialTxVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(1, numElems, 1)
}
func BoosterAddLimit(builder *flatbuffers.Builder, limit int64) {
	builder.PrependInt64Slot(9, limit, 0)
}
func BoosterAddMaxAge(builder *flatbuffers.Builder, maxAge int64) {
	builder.PrependInt64Slot(10, maxAge, 0)
}
func BoosterAddMinAge(builder *flatbuffers.Builder, minAge int64) {
	builder.PrependInt64Slot(11, minAge, 0)
}
func BoosterAddGenders(builder *flatbuffers.Builder, genders flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(12, flatbuffers.UOffsetT(genders), 0)
}
func BoosterStartGendersVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func BoosterAddInterests(builder *flatbuffers.Builder, interests flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(13, flatbuffers.UOffsetT(interests), 0)
}
func BoosterStartInterestsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func BoosterAddAreas(builder *flatbuffers.Builder, areas flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(14, flatbuffers.UOffsetT(areas), 0)
}
func BoosterStartAreasVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func BoosterAddBoostMessage(builder *flatbuffers.Builder, boostMessage flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(15, flatbuffers.UOffsetT(boostMessage), 0)
}
func BoosterStartBoostMessageVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(1, numElems, 1)
}
func BoosterAddFullMedia(builder *flatbuffers.Builder, fullMedia flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(16, flatbuffers.UOffsetT(fullMedia), 0)
}
func BoosterStartFullMediaVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(1, numElems, 1)
}
func BoosterEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
